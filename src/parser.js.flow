// @flow

import HTTPSnippet from 'httpsnippet';
import cheerio from 'cheerio';
import markdownIt from 'markdown-it';
import {at, sanitize, slugify, capitalize} from './util';

export class RefractParser {
    languages: Array<Object> = [
        {name: 'curl', displayName: 'cURL', snippet: {target: 'shell', client: 'curl'}, hljs: 'bash'},
        {name: 'node', displayName: 'NodeJS', snippet: {target: 'node', client: 'request'}, hljs: 'javascript'},
        {name: 'python', displayName: 'Python', snippet: {target: 'python', client: 'python3'}, hljs: 'python'},
        {name: 'java', displayName: 'Java', snippet: {target: 'java', client: 'okhttp'}, hljs: 'java'},
        {name: 'ruby', displayName: 'Ruby', snippet: {target: 'ruby', client: 'native'}, hljs: 'ruby'},
        {name: 'php', displayName: 'PHP', snippet: {target: 'php', client: 'ext-curl'}, hljs: 'php'},
        {name: 'go', displayName: 'Go', snippet: {target: 'go', client: 'native'}, hljs: 'go'}
    ];

    options: {
        apiUrl: 'http://example.com/api/v1'
    };

    markdownIt: markdownIt;

    constructor(options: Object = {}) {
        this.options = Object.assign({}, this.options, options);

        // Markdown parser
        this.markdownIt = markdownIt({
            html: true,
            linkify: true,
            typographer: true
        });

        this.markdownIt.use(require('markdown-it-anchor'), {
            permalink: true
        });
    }

    parse(doc: Object): Object {
        if (!doc.element && !doc.element === 'parseResult') {
            throw new Error('Input is not a valid refract object.');
        }

        return {
            type: 'result',
            content: sanitize(
                doc.content.map(content => {
                    return this._parse(content, {}, {type: 'result'}).current;
                })
            )
        };
    }

    getDataStructures(doc: Object): Array<Object> {
        if (!doc.type && !doc.type === 'result') {
            throw new Error('Input is not a valid RefractParser result object.');
        }

        let ds = at(doc, 'content.0.content');

        ds = ds && ds.find(el => el.type === 'dataStructures');
        return (ds && ds.content) || [];
    }

    getLanguages(): Array<Object> {
        return this.languages;
    }

    _parse(doc: Object, current: Object = {}, parent: Object = {}): Object {
        try {
            switch (doc.element) {
                case 'copy':
                    ({doc, current, parent} = this._parseCopy(doc, current, parent));
                    break;
                case 'category':
                    ({doc, current, parent} = this._parseCategory(doc, current, parent));
                    break;
                case 'resource':
                    ({doc, current, parent} = this._parseResource(doc, current, parent));
                    break;
                case 'transition':
                    ({doc, current, parent} = this._parseTransition(doc, current, parent));
                    break;
                case 'dataStructure':
                    ({doc, current, parent} = this._parseDataStructure(doc, current, parent));
                    break;
                case 'httpTransaction':
                    ({doc, current, parent} = this._parseHttpTransaction(doc, current, parent));
                    break;
                case 'httpRequest':
                    ({doc, current, parent} = this._parseHttpRequest(doc, current, parent));
                    break;
                case 'httpResponse':
                    ({doc, current, parent} = this._parseHttpResponse(doc, current, parent));
                    break;
                case 'asset':
                    ({doc, current, parent} = this._parseAsset(doc, current, parent));
                    break;
                default:
                    break;
            }
        } catch (err) {
            console.error(err);
        }

        return {
            doc: doc,
            current: current,
            parent: parent
        };
    }

    _parseCopy(doc: Object, current: Object, parent: Object): Object {
        let description = this.markdownIt.render(doc.content);
        let $ = cheerio.load(description);

        parent.description = {
            text: description,
            links: $('.header-anchor').map((index, el) => {
                return $(el).attr('href');
            }).toArray()
        };

        return {
            doc: doc,
            current: undefined,
            parent: parent
        };
    }

    _parseCategory(doc: Object, current: Object, parent: Object): Object {
        let meta: Object = this._getMeta(doc.meta);
        current.type = meta.class;

        if (current.type === 'dataStructures') {
            current.title = meta.title;
            current.content = doc.content.map(ds => {
                let content = ds.content && ds.content[0];
                return {
                    id: content.meta && content.meta.id,
                    content: content
                };
            });
        } else {
            current.id = 'group-' + slugify(meta.title || parent.title);
            current.title = meta.title;
            current.content = sanitize(
                doc.content.map(content => {
                    return this._parse(content, {}, current).current;
                })
            );
        }

        return {
            doc: doc,
            current: current,
            parent: parent
        };
    }

    _parseResource(doc: Object, current: Object, parent: Object): Object {
        let meta: Object = this._getMeta(doc.meta);

        current.type = 'resource';
        current.title = meta.title;
        current.id = 'resource-' + slugify(meta.title);
        current.props = this._getProps(doc.attributes);
        current.content = sanitize(
            doc.content.map(content => {
                return this._parse(content, {}, current).current;
            })
        );

        return {
            doc: doc,
            current: current,
            parent: parent
        };
    }

    _parseTransition(doc: Object, current: Object, parent: Object): Object {
        let meta: Object = this._getMeta(doc.meta);

        current.type = 'transition';
        current.title = meta.title;
        current.props = this._getProps(doc.attributes);
        current.content = sanitize(
            doc.content.map(content => {
                return this._parse(content, {}, current).current;
            })
        );

        let method = at(current, 'content.0.content.0.props.method');
        current.id = 'transition-' + slugify(meta.title + '-' + method);
        current.xhrContent = this._xhrContent(current, parent);
        current.snippets = {};

        for (let lang of this.languages) {
            current.snippets[lang.name] = unescape((new HTTPSnippet(current.xhrContent)).convert(lang.snippet.target, lang.snippet.type));
        }

        return {
            doc: doc,
            current: current,
            parent: parent
        };
    }

    _parseDataStructure(doc: Object, current: Object, parent: Object): Object {
        current.type = 'dataStructure';
        current.content = doc.content;

        let trId = capitalize(current.content[0] && current.content[0].meta && current.content[0].meta.id);

        if (trId) {
            current.id = 'object-' + slugify(trId);
            current.title = trId + ' Object';
        }

        return {
            doc: doc,
            current: current,
            parent: parent
        };
    }

    _parseHttpTransaction(doc: Object, current: Object, parent: Object): Object {
        let meta: Object = this._getMeta(doc.meta);

        current.type = 'httpTransaction';
        current.title = meta.title;
        current.props = {};
        current.content = sanitize(
            doc.content.map(content => {
                return this._parse(content, {}, current).current;
            })
        );

        return {
            doc: doc,
            current: current,
            parent: parent
        };
    }

    _parseHttpRequest(doc: Object, current: Object, parent: Object): Object {
        let meta: Object = this._getMeta(doc.meta);

        current.type = 'httpRequest';
        current.title = meta.title;
        current.props = this._getProps(doc.attributes);
        current.content = sanitize(
            doc.content.map(content => {
                return this._parse(content, {}, current).current;
            })
        );

        return {
            doc: doc,
            current: current,
            parent: parent
        };
    }

    _parseHttpResponse(doc: Object, current: Object, parent: Object): Object {
        let meta: Object = this._getMeta(doc.meta);

        current.type = 'httpResponse';
        current.title = meta.title;
        current.props = this._getProps(doc.attributes);
        current.content = sanitize(
            doc.content.map(content => {
                return this._parse(content, {}, current).current;
            })
        );

        return {
            doc: doc,
            current: current,
            parent: parent
        };
    }

    _parseAsset(doc: Object, current: Object, parent: Object): Object {
        let meta: Object = this._getMeta(doc.meta);

        if (meta.class === 'messageBody') {
            current.type = 'body';
            current.title = meta.title;
            current.content = doc.content;
        }

        return {
            doc: doc,
            current: current,
            parent: parent
        };
    }

    _getMeta(meta: Object = {}) {
        let classes = '';

        if (meta.classes && Array.isArray(meta.classes) && meta.classes.length > 0) {
            classes = meta.classes[0];
        }

        return {
            class: classes,
            title: meta.title
        };
    }

    _getProps(props: Object = {}) {
        let urlParameters: Array<Object> = [];
        let headers: Array<Object> = [];
        let data: string = '';

        if (props.hrefVariables && props.hrefVariables.content) {
            for (let variable of props.hrefVariables.content) {
                urlParameters.push({
                    wfn: variable.meta && variable.meta.description,
                    key: variable.content && variable.content.key,
                    value: variable.content && variable.content.value
                });
            }
        }

        if (props.headers && props.headers.content) {
            for (let variable of props.headers.content) {
                headers.push({
                    key: variable.content && variable.content.key,
                    value: variable.content && variable.content.value
                });
            }
        }

        if (props.data && props.data.element === 'dataStructure') {
            data = props.data.content;
        }

        return {
            url: props.href,
            method: props.method,
            data: data,
            headers: headers,
            statusCode: props.statusCode,
            urlParameters: urlParameters
        };
    }

    _xhrContent(transition: Object, resource: Object) {
        let httpRequest: Object = at(transition, 'content.0.content.0');

        let requestProps: Object = httpRequest && httpRequest.props;
        requestProps = requestProps || {};

        let transProps: Object = transition.props || {};

        let urlParameters: Array<Object> = Object.assign(transProps.urlParameters, requestProps.urlParameters);

        let postData = httpRequest.content && httpRequest.content.find(c => c.type === 'body');

        let mimeType: string = requestProps.headers.find(c => c.type === 'Content-Type') || 'application/json';

        let url: string = requestProps.url || transProps.url;
        let queryStrings: Array<Object> = [];

        if (!url && resource.type === 'resource') {
            url = resource.props && resource.props.url;
            if (resource.props.urlParameters) {
                urlParameters = Object.assign(resource.props.urlParameters, urlParameters);
            }
        }

        let hrefSplits: Array<string> = (url && url.split('{?')) || [];
        if (hrefSplits.length > 1) {
            url = hrefSplits[0];
            let qs = hrefSplits[1].replace('}', '').split(',');

            queryStrings = qs.map(qs => ({
                name: qs.trim(),
                value: '{' + qs.trim() + '}'
            }));
        }

        let originalUrl = url;

        for (let param: Object of urlParameters) {
            let key = param.key && param.key.content;
            let value = param.value && param.value.content;

            if (!key || !value) {
                continue;
            }

            let replaceRegex = new RegExp('{' + key + '}', 'g');
            url = url.replace(replaceRegex, value);
        }

        return {
            method: requestProps.method,
            url: this.options.apiUrl + url,
            originalUrl: this.options.apiUrl + originalUrl,
            httpVersion: 'unknown',
            queryString: queryStrings,
            headers: requestProps.headers.map(header => ({
                name: header.key && header.key.content,
                value: header.value && header.value.content
            })),
            attributes: Object.assign(transProps.data, requestProps.data),
            urlParameters: urlParameters,
            postData: {
                mimeType: mimeType,
                postData: postData && postData.content
            },
            headersSize: -1,
            bodySize: -1,
            comment: ''
        };
    }
}
