// @flow

import HTTPSnippet from 'httpsnippet';
import cheerio from 'cheerio';
import markdownIt from 'markdown-it';
import {sanitize, slugify, capitalize} from './util';

export class RefractParser {

    options: {
        apiUrl: 'http://example.com/api/v1',
        languages: []
    };

    markdownIt: markdownIt;

    constructor(options: Object = {}) {
        this.options = Object.assign({}, this.options, options);

        // Markdown parser
        this.markdownIt = markdownIt({
            html: true,
            linkify: true,
            typographer: true
        });

        this.markdownIt.use(require('markdown-it-anchor'), {
            permalink: true
        });
    }

    parse(doc: Object): Object {
        if (!doc.element && !doc.element === 'parseResult') {
            throw new Error('Input is not a valid refract object.');
        }

        let result: ?Object = (doc && doc.content && doc.content.length > 0) ? this._parse(doc.content[0], {}, {type: 'result'}).current : null;

        return {
            type: 'result',
            languages: this.options.languages,
            content: result,
            dataStructures: this._getDataStructures(result)
        };
    }

    _parse(doc: Object, current: Object = {}, parent: Object = {}): Object {
        try {
            switch (doc.element) {
                case 'copy':
                    ({doc, current, parent} = this._parseCopy(doc, current, parent));
                    break;
                case 'category':
                    ({doc, current, parent} = this._parseCategory(doc, current, parent));
                    break;
                case 'resource':
                    ({doc, current, parent} = this._parseResource(doc, current, parent));
                    break;
                case 'transition':
                    ({doc, current, parent} = this._parseTransition(doc, current, parent));
                    break;
                case 'dataStructure':
                    ({doc, current, parent} = this._parseDataStructure(doc, current, parent));
                    break;
                case 'httpTransaction':
                    ({doc, current, parent} = this._parseHttpTransaction(doc, current, parent));
                    break;
                case 'httpRequest':
                    ({doc, current, parent} = this._parseHttpRequest(doc, current, parent));
                    break;
                case 'httpResponse':
                    ({doc, current, parent} = this._parseHttpResponse(doc, current, parent));
                    break;
                case 'asset':
                    ({doc, current, parent} = this._parseAsset(doc, current, parent));
                    break;
                default:
                    break;
            }
        } catch (err) {
            console.error(err);
        }

        return {
            doc: doc,
            current: current,
            parent: parent
        };
    }

    _parseCopy(doc: Object, current: Object, parent: Object): Object {
        let description = this.markdownIt.render(doc.content);
        let $ = cheerio.load(description);

        parent.description = {
            text: description,
            links: $('.header-anchor').map((index, el) => {
                return $(el).attr('href');
            }).toArray()
        };

        return {
            doc: doc,
            current: undefined,
            parent: parent
        };
    }

    _parseCategory(doc: Object, current: Object, parent: Object): Object {
        let meta: Object = this._getMeta(doc.meta);
        current.type = meta.class;

        if (current.type === 'dataStructures') {
            current.title = meta.title;
            current.content = doc.content.map(ds => {
                let content = ds.content && ds.content[0];
                return {
                    id: content.meta && content.meta.id,
                    content: content
                };
            });
        } else {
            current.id = 'group-' + slugify(meta.title || parent.title);
            current.title = meta.title;
            current.content = sanitize(
                doc.content.map(content => {
                    return this._parse(content, {}, current).current;
                })
            );
        }

        return {
            doc: doc,
            current: current,
            parent: parent
        };
    }

    _parseResource(doc: Object, current: Object, parent: Object): Object {
        let meta: Object = this._getMeta(doc.meta);

        current.type = 'resource';
        current.title = meta.title;
        current.id = 'resource-' + slugify(meta.title);
        current.props = this._getProps(doc.attributes);
        current.content = sanitize(
            doc.content.map(content => {
                return this._parse(content, {}, current).current;
            })
        );

        return {
            doc: doc,
            current: current,
            parent: parent
        };
    }

    _parseTransition(doc: Object, current: Object, parent: Object): Object {
        let meta: Object = this._getMeta(doc.meta);

        current.type = 'transition';
        current.title = meta.title;
        current.props = this._getProps(doc.attributes);
        current.transaction = doc.content.find(el => {
            return el && el.element && el.element === 'httpTransaction';
        }) || null;

        current.transaction = current.transaction && this._parse(current.transaction, {}, current).current;

        let method = current.transaction && current.transaction.request.props.method;
        if (method) {
            method = '-' + method;
        }

        current.id = 'transition-' + slugify(meta.title + method);
        current.xhrContent = this._xhrContent(current, parent);
        current.snippets = {};

        if (current.xhrContent) {
            for (let lang of this.options.languages) {
                current.snippets[lang.name] = unescape((new HTTPSnippet(current.xhrContent)).convert(lang.snippet.target, lang.snippet.type));
            }
        }

        return {
            doc: doc,
            current: current,
            parent: parent
        };
    }

    _parseDataStructure(doc: Object, current: Object, parent: Object): Object {
        current.type = 'dataStructure';
        current.content = doc.content;

        let trId = capitalize(current.content[0] && current.content[0].meta && current.content[0].meta.id);

        if (trId) {
            current.id = 'object-' + slugify(trId);
            current.title = trId + ' Object';
        }

        return {
            doc: doc,
            current: current,
            parent: parent
        };
    }

    _parseHttpTransaction(doc: Object, current: Object, parent: Object): Object {
        let meta: Object = this._getMeta(doc.meta);

        current.type = 'httpTransaction';
        current.title = meta.title;
        current.props = {};

        // Request
        current.request = doc.content.find(el => {
            return el.element && el.element === 'httpRequest';
        }) || null;

        current.request = current.request && this._parse(current.request, {}, current).current;

        // Responses
        current.responses = doc.content.filter(el => {
            return el && el.element && el.element === 'httpResponse';
        }) || [];

        current.responses = current.responses.map(response => {
            return this._parse(response, {}, current).current;
        });

        return {
            doc: doc,
            current: current,
            parent: parent
        };
    }

    _parseHttpRequest(doc: Object, current: Object, parent: Object): Object {
        let meta: Object = this._getMeta(doc.meta);

        current.type = 'httpRequest';
        current.title = meta.title;
        current.props = this._getProps(doc.attributes);

        // Request body
        let content = sanitize(
            doc.content.map(content => {
                return this._parse(content, {}, current).current;
            })
        );

        current.body = content.find(el => {
            return el.type && el.type === 'body';
        });

        current.body = current.body && current.body.content;

        return {
            doc: doc,
            current: current,
            parent: parent
        };
    }

    _parseHttpResponse(doc: Object, current: Object, parent: Object): Object {
        let meta: Object = this._getMeta(doc.meta);

        current.type = 'httpResponse';
        current.title = meta.title;
        current.props = this._getProps(doc.attributes);

        // Response body
        let content = sanitize(
            doc.content.map(content => {
                return this._parse(content, {}, current).current;
            })
        );

        current.body = content.find(el => {
            return el.type && el.type === 'body';
        });

        current.body = current.body && current.body.content;

        return {
            doc: doc,
            current: current,
            parent: parent
        };
    }

    _parseAsset(doc: Object, current: Object, parent: Object): Object {
        let meta: Object = this._getMeta(doc.meta);

        if (meta.class === 'messageBody') {
            current.type = 'body';
            current.title = meta.title;
            current.content = doc.content;
        }

        return {
            doc: doc,
            current: current,
            parent: parent
        };
    }

    _getMeta(meta: Object = {}) {
        let classes = '';

        if (meta.classes && Array.isArray(meta.classes) && meta.classes.length > 0) {
            classes = meta.classes[0];
        }

        return {
            class: classes,
            title: meta.title
        };
    }

    _getProps(props: Object = {}) {
        let urlParameters: Array<Object> = [];
        let headers: Array<Object> = [];
        let data: string = '';

        if (props.hrefVariables && props.hrefVariables.content) {
            for (let variable of props.hrefVariables.content) {
                urlParameters.push({
                    wfn: variable.meta && variable.meta.description,
                    key: variable.content && variable.content.key,
                    value: variable.content && variable.content.value
                });
            }
        }

        if (props.headers && props.headers.content) {
            for (let variable of props.headers.content) {
                headers.push({
                    key: variable.content && variable.content.key,
                    value: variable.content && variable.content.value
                });
            }
        }

        if (props.data && props.data.element === 'dataStructure') {
            data = props.data.content;
        }

        return {
            url: props.href,
            method: props.method,
            data: data,
            headers: headers,
            statusCode: props.statusCode,
            urlParameters: urlParameters
        };
    }

    _xhrContent(transition: Object, resource: Object) {
        let httpRequest: Object = transition.transaction.request;

        let requestProps: Object = httpRequest && httpRequest.props;
        requestProps = requestProps || {};

        let transProps: Object = transition.props || {};

        let urlParameters: Array<Object> = Object.assign(transProps.urlParameters, requestProps.urlParameters);

        let postData = httpRequest.content && httpRequest.content.find(c => c.type === 'body');

        let mimeType: string = requestProps.headers.find(c => c.type === 'Content-Type') || 'application/json';

        let url: string = requestProps.url || transProps.url;
        let queryStrings: Array<Object> = [];

        if (!url && resource.type === 'resource') {
            url = resource.props && resource.props.url;
            if (resource.props.urlParameters) {
                urlParameters = Object.assign(resource.props.urlParameters, urlParameters);
            }
        }

        let hrefSplits: Array<string> = (url && url.split('{?')) || [];
        if (hrefSplits.length > 1) {
            url = hrefSplits[0];
            let qs = hrefSplits[1].replace('}', '').split(',');

            queryStrings = qs.map(qs => ({
                name: qs.trim(),
                value: '{' + qs.trim() + '}'
            }));
        }

        let originalUrl = url;

        for (let param: Object of urlParameters) {
            let key = param.key && param.key.content;
            let value = param.value && param.value.content;

            if (!key || !value) {
                continue;
            }

            let replaceRegex = new RegExp('{' + key + '}', 'g');
            url = url.replace(replaceRegex, value);
        }

        return {
            method: requestProps.method,
            url: this.options.apiUrl + url,
            originalUrl: this.options.apiUrl + originalUrl,
            httpVersion: 'unknown',
            queryString: queryStrings,
            headers: requestProps.headers.map(header => ({
                name: header.key && header.key.content,
                value: header.value && header.value.content
            })),
            attributes: Object.assign(transProps.data, requestProps.data),
            urlParameters: urlParameters,
            postData: {
                mimeType: mimeType,
                postData: postData && postData.content
            },
            headersSize: -1,
            bodySize: -1,
            comment: ''
        };
    }

    /**
     * Get data structures from document
     * @param {Object} doc Parsed result document
     * @return {Array.Object|null} Data structures
     */
    _getDataStructures(doc: ?Object): ?Array<Object> {
        if (!doc) {
            return null;
        }

        // Find data structures
        let structures = doc.content.find(el => el.type === 'dataStructures');

        return structures ? structures.content : null;
    }
}
